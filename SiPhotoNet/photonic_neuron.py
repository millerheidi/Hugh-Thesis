#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
    Class file for neuron with MRR weight bank, and O/E/O transmission    
    
    @author: Hugh Morison

    --- WEIGHT MATRIX CONVENTION ---
    
    adopting the convention that the weight matrix is NxN (fully connected)
         _                    _
        | w11  w12  w13 .. w1m |
    W = | w21  ..          w2m |   where  W[n][m] is the weight of the mth
        | ..        ..         |          MRR in the nth neuron (modulating
        | wn1           .. wnm |          the mth signal from the waveguide)
         -                    -
         
    the nth neuron in the network modulates the nth output signal

"""
import numpy as np
 
class neuron:
    def __init__(self, weights, wavelength, L = 3e-5 , a = 0.99, r1 = 0.9, r2 = 0.9, outPower = 1.0):
        self.weights = weights
        self.output_wavelength = wavelength
        self.output_power = outPower
        
        self.L = L
        self.a = a
        self.r1 = r1
        self.r2 = r2
    
    @staticmethod
    def lambda_to_phi(n_0, i_mod, coeff_mod, i_heater, coeff, L, wavelength):
        return (2*np.pi*L/wavelength) * (n_0 + i_mod*coeff_mod + coeff*i_heater**2) 
    
    def mrr(self, i, wavelength):
        heater = self.weights[i]*1.0e-3
        phi = neuron.lambda_to_phi(np.sqrt(12), 0.0, 0.0, heater, 5e2, self.L, wavelength)
        numerator_t = (self.r2*self.a)**2 + self.r1**2 - 2*self.r1*self.r2*self.a*np.cos(phi)
        numerator_d = (1-self.r1**2)*(1-self.r2**2)*self.a
        denominator = 1 + (self.a*self.r1*self.r2)**2 - 2*self.r1*self.r2*self.a*np.cos(phi)
        return {'thru': numerator_t/denominator, 'drop': numerator_d/denominator}

    def weightBank(self, waveguide):
        thrus = []
        drops = []
        for i,signal in enumerate(waveguide):
            MRR = self.mrr(i, signal['wavelength'])
            thrus.append(signal['power'] * MRR['thru'])
            drops.append(signal['power'] * MRR['drop'])
        return {'thrus': thrus, 'drops': drops} 
  
    def photodiode(self, thru, drop):
        # calculate the current generated by the photodiode configuration
        # NOT IMPLEMENTED YET
        return -1
    
    def modulate(self, current):
        # modulate the neuron's signal based on the current
        phi = neuron.lambda_to_phi(np.sqrt(12), current, 1e2, 0.0, 5e2, self.L, self.output_wavelength)
        numerator = self.a**2 + self.r1**2 - 2*self.r1*self.a*np.cos(phi)
        denominator = 1 + (self.a*self.r1)**2 - 2*self.r1*self.a*np.cos(phi)
        return numerator/denominator
    
    def nextState(self, waveguide):
        tunedWaveguides = self.weightBank(waveguide)
        current = self.photodiode(tunedWaveguides['thru'], tunedWaveguides['drop'])
        power = self.modulate(current)
        return power