#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Class file for neuron with MRR weight bank and O/E/O transmission    

@author: Hugh Morison

"""
import numpy as np
import copy
import matplotlib.pyplot as plt
import math

class neuron:

    def __init__(self, weights, wavelength, voltage_bias, net_wavelengths = [], mrr_radius = 11.5e-6, a = 0.99, r1 = 0.97, r2 = 0.948):
        """
            Neuron takes a list of weights and an output wavelength.
            
            The radius of the ring (mrr_radius), the loss in the ring (a), and the
            self-coupling coefficients (r1 and r2) can be changed.
        """
        self.output_wavelength = wavelength
        self.net_wavelengths = net_wavelengths
        self.weights = self.weightToHeaterCurrent(weights, net_wavelengths)
        self.mrr_radius = mrr_radius
        self.a = a
        self.r1 = r1
        self.r2 = r2
        self.voltage_bias = voltage_bias
        self.voltage = voltage_bias
        self.Rb = 1
        self.Cmod = 1
    
    def __str__(self):
        """
            Neuron string representation.
        """
        return 'Photoneuron instance. Channel: ' + str(self.output_wavelength) + ' Weights:' + str(self.weights)
    
    def getModulation(self, incident, idx):
        """
            Apply neuron transfer function to incident waveguide and return the 
            modulator transmission.
        """
        incidentWaveguide = copy.deepcopy(incident.split_wg[idx])
        thru, drop = self.weightBankTransmission(incident.wavelengths)
        current = self.photodiode(incidentWaveguide*thru, incidentWaveguide*drop)
        transmission = self.modulatorTransmission(current, 0)
        return transmission
    
    def weightBankTransmission(self, wavelengths):
        """
            Get through and drop port transmissions for each incident wavelength.
        """
        thru = 1.0
        drop = 0.0
        for current in self.weights:
            mrr = self.mrrThruDrop(current, wavelengths)
            drop += thru * mrr.drop
            thru *= mrr.thru
        return thru, drop
    
    def detuneByWavelength(self, wavelength, n_0 = np.sqrt(12), i_mod = 0.0, i_heater = 0.0, coeff = 5e2):
        """
            Get phase shift induced by MRR w/ thermo-optic effect (weight bank) or 
            electro-optic efffect (modulator).
        """
        return (2*np.pi*self.mrr_radius/wavelength) * (n_0 + self.plasmaDispersion(n_0, i_mod) + coeff*i_heater**2) 
    
    def plasmaDispersion(self, n_0, i_mod):
        """
        """
        eps0 = 8.854e-12
        c = 3e8
        e = 1.6e-19
        lamb0 = self.output_wavelength
        me = 1 # TODO: find me, mh vals then use 'real' or 'approx'
        mh = 1
        Ne = i_mod
        Nh = i_mod
        real = -((e**2 * lamb0**2)/(8 * math.pi**2 * c**3 * eps0 * n_0))*((Ne/me) + (Nh/mh))
        approx = -(8.8e-22*Ne + 8.5e-18*Nh**0.8) 
        return -0.1*i_mod # not correct just estimate
    
    def mrrThruDrop(self, heater, wavelengths):
        """
        """
        a = self.a
        r1 = self.r1
        r2 = self.r2
        phis = self.detuneByWavelength(wavelengths, i_heater=heater)
        numerator_t = (r2*a)**2 - 2*r1*r2*a*np.cos(phis) + r1**2 
        numerator_d = (1-r1**2)*(1-r2**2)*a
        denominator = 1 + (a*r1*r2)**2 - 2*r1*r2*a*np.cos(phis)
        class mrr: pass
        mrr.thru = numerator_t/denominator
        mrr.drop = numerator_d/denominator
        return mrr
    
    def modulatorTransmission(self, current, I_h):
        """
        """
        a = self.a
        r = self.r1
        phi = self.detuneByWavelength(self.output_wavelength, i_mod=current, i_heater = I_h)
        numerator = a**2 + r**2 - 2*r*a*np.cos(phi)
        denominator = 1 + (a*r)**2 - 2*r*a*np.cos(phi)
        return numerator/denominator
    
    def photodiode(self, p_thru, p_drop):
        """
            Calculate the current generated by the photodiode configuration.
        """
        wavelength = 1550e-9 # [m] TODO: add wavelength dependance
        eta = 0.50 # [%]
        responsivity = eta * (wavelength / (1.23985e-6)) # [A/W]
        current_thru = sum(responsivity*p_thru) # [A]
        current_drop = sum(responsivity*p_drop) # [A]
        self.voltage += -(self.voltage - self.voltage_bias)/(self.Rb * self.Cmod) + (current_drop - current_thru)/self.Cmod
        impedance = 1
        return self.voltage/impedance
    
    def weightToHeaterCurrent(self, weights, wavelengths):
        """
        """
        wavelengths = np.array(wavelengths)
        weights = np.array(weights)
        
        return [weight*1e-3 for weight in weights] # [A]
    
    def plotWeightBank(self):
        """
            Visual representation of weight bank transfer functions
        """
        lambdas = np.linspace(self.output_wavelength - 15e-9,self.output_wavelength + 20e-9,500)
        plt.figure()
        for i,weight in enumerate(self.weights):
            mrr = self.mrrThruDrop(weight, lambdas)
            plt.plot(lambdas*1e9, mrr.thru, color="C" + str(i))
            plt.plot(lambdas*1e9, mrr.drop, "--C" + str(i))
        #labels = ['Through', 'Drop', 'Total']
        #plt.legend([labels[i] + ' W=' + str(w*1e3) for w in self.weights for i in range(3)])
        plt.vlines(self.output_wavelength*1e9,0,1)
        plt.xlabel('Wavelength [nm]')
        plt.ylabel('Transmission [norm.]')
        plt.show()
    


        